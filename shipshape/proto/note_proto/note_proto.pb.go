// Code generated by protoc-gen-go.
// source: shipshape/proto/note.proto
// DO NOT EDIT!

/*
Package note_proto_go_src is a generated protocol buffer package.

It is generated from these files:
	shipshape/proto/note.proto

It has these top-level messages:
	Note
	Location
	Fix
	Replacement
	FixRange
	AdditionalData
*/
package note_proto_go_src

import proto "github.com/golang/protobuf/proto"
import math "math"
import shipshape_proto "github.com/google/shipshape/shipshape/proto/textrange_proto"
import source_v1 "github.com/google/shipshape/shipshape/proto/source_context_proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// Severity of the annotation, used to distinguish build/compiler
// errors, i.e. where a binary fails to be built (BUILD_ERROR),
// other actionable results (WARNING), and informational notes (OTHER).
// TODO(supertri): Is there any other kind of prioritization we need?
type Note_Severity int32

const (
	// Build did not succeed because of this issue.
	Note_BUILD_ERROR Note_Severity = 1
	// Actionable problem, e.g. that a developer needs to fix.
	Note_WARNING Note_Severity = 2
	// There are 3 possibilities in the Java library Diagnostic.Kind enum
	// in addition to WARNING and ERROR (one is called "OTHER").
	// This value gives a way to propagate these other diagnostic types with a
	// default label which avoids incorrectly marking them as one of the other
	// 2 categories.
	Note_OTHER Note_Severity = 3
)

var Note_Severity_name = map[int32]string{
	1: "BUILD_ERROR",
	2: "WARNING",
	3: "OTHER",
}
var Note_Severity_value = map[string]int32{
	"BUILD_ERROR": 1,
	"WARNING":     2,
	"OTHER":       3,
}

func (x Note_Severity) Enum() *Note_Severity {
	p := new(Note_Severity)
	*p = x
	return p
}
func (x Note_Severity) String() string {
	return proto.EnumName(Note_Severity_name, int32(x))
}
func (x *Note_Severity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Note_Severity_value, data, "Note_Severity")
	if err != nil {
		return err
	}
	*x = Note_Severity(value)
	return nil
}

// A Note is an arbitrary annotation, attached to a location in a
// source file, an entire file, or a particular snapshot (e.g. associated with
// either a code review or a revision).
// Code Notes include (human) review comments, robot comments, and UI-visible
// annotations generated from dynamic information.
type Note struct {
	// An identifier for the category of this note (e.g. Lint).
	// Should be distinct and contain no spaces.
	// Pascalcase (e.g. ErrorProne) preferred.
	// TODO(supertri): How will we prevent duplicate category names?
	Category    *string `protobuf:"bytes,1,opt,name=category" json:"category,omitempty"`
	Subcategory *string `protobuf:"bytes,2,opt,name=subcategory" json:"subcategory,omitempty"`
	// The location of the Note in the code for which the notes have been
	// requested.
	Location *Location `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	// A short plain text human readable description of the Note.
	// For example "Line is greater than 80 characters" for a Lint warning,
	// the text of the code review comment, or "Error logged in production:
	// cannot connect to Foo" for a Note about dynamic logs data.
	Description *string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// Optional link to more detailed information about the message or analyzer.
	MoreInfo *string `protobuf:"bytes,5,opt,name=more_info" json:"more_info,omitempty"`
	// Additional category or environment specific data for the note.
	AdditionalData *AdditionalData `protobuf:"bytes,6,opt,name=additional_data" json:"additional_data,omitempty"`
	// Optional suggested fixes for the note. If multiple ones are present,
	// they should be ordered by descending preference.
	Fix []*Fix `protobuf:"bytes,7,rep,name=fix" json:"fix,omitempty"`
	// Severity of this note, e.g., a compiler diagnostic.
	// Distinguishes between Notes representing build errors or other actionable
	// problems, and informational Notes. Useful for UI because
	// different annotations may need various levels of attention from the user.
	Severity         *Note_Severity `protobuf:"varint,8,opt,name=severity,enum=shipshape_proto.Note_Severity,def=2" json:"severity,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Note) Reset()         { *m = Note{} }
func (m *Note) String() string { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()    {}

const Default_Note_Severity Note_Severity = Note_WARNING

func (m *Note) GetCategory() string {
	if m != nil && m.Category != nil {
		return *m.Category
	}
	return ""
}

func (m *Note) GetSubcategory() string {
	if m != nil && m.Subcategory != nil {
		return *m.Subcategory
	}
	return ""
}

func (m *Note) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Note) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *Note) GetMoreInfo() string {
	if m != nil && m.MoreInfo != nil {
		return *m.MoreInfo
	}
	return ""
}

func (m *Note) GetAdditionalData() *AdditionalData {
	if m != nil {
		return m.AdditionalData
	}
	return nil
}

func (m *Note) GetFix() []*Fix {
	if m != nil {
		return m.Fix
	}
	return nil
}

func (m *Note) GetSeverity() Note_Severity {
	if m != nil && m.Severity != nil {
		return *m.Severity
	}
	return Default_Note_Severity
}

// A location within a specific file, a single file, or a snapshot.
type Location struct {
	// The context in which to interpret the path and the range, e.g. the
	// location of a specific revision in a repo.
	// TODO(supertri): Replace with source API SourceContext proto when ready.
	SourceContext *source_v1.SourceContext `protobuf:"bytes,1,opt,name=source_context" json:"source_context,omitempty"`
	// A path of a file within the given context. If only context and path are
	// present, the location refers to an entire file or path.
	// If the path ends in "/" it indicates a directory, otherwise a file name.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// A range within the given file. If a range is set, a path must also be set.
	Range            *shipshape_proto.TextRange `protobuf:"bytes,3,opt,name=range" json:"range,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}

func (m *Location) GetSourceContext() *source_v1.SourceContext {
	if m != nil {
		return m.SourceContext
	}
	return nil
}

func (m *Location) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *Location) GetRange() *shipshape_proto.TextRange {
	if m != nil {
		return m.Range
	}
	return nil
}

// A suggested fix for a note.
type Fix struct {
	// An optional short human readable description that may be shown in a UI.
	Description *string `protobuf:"bytes,1,opt,name=description" json:"description,omitempty"`
	// The context in which to interpret the path and the range inside the
	// replacement, e.g. the location of a specific revision in a repo.
	// Must match the source_context in the enclosing note.
	SourceContext *source_v1.SourceContext `protobuf:"bytes,2,opt,name=source_context" json:"source_context,omitempty"`
	// A delta to be applied to a specific file(s).
	// Replacements must be grouped by file and within the file ordered by
	// the range. Replacements for a given fix must not overlap.
	Replacement      []*Replacement `protobuf:"bytes,3,rep,name=replacement" json:"replacement,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Fix) Reset()         { *m = Fix{} }
func (m *Fix) String() string { return proto.CompactTextString(m) }
func (*Fix) ProtoMessage()    {}

func (m *Fix) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *Fix) GetSourceContext() *source_v1.SourceContext {
	if m != nil {
		return m.SourceContext
	}
	return nil
}

func (m *Fix) GetReplacement() []*Replacement {
	if m != nil {
		return m.Replacement
	}
	return nil
}

// A replacement to be applied to a single location. The location of the
// Replacement may be an arbitrary file.
// Replacements are independent, that is if there are multiple ones touching
// the same file, the location always refers to the original file rather than
// the file with other Replacements applied.
type Replacement struct {
	// A path of a file within the given context. If only path is
	// present, the location refers to an entire file or path.
	// If the path ends in "/" it indicates a directory, otherwise a file name.
	Path *string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// The range of text to replace with this fix; can be specified either with
	// bytes or lines.
	Range *FixRange `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	// The new content to put in the given location. The length of the
	// replacement does not need to be identical with the text to be
	// replaced. The encoding must be the same as in the original file.
	NewContent       *string `protobuf:"bytes,3,opt,name=new_content" json:"new_content,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Replacement) Reset()         { *m = Replacement{} }
func (m *Replacement) String() string { return proto.CompactTextString(m) }
func (*Replacement) ProtoMessage()    {}

func (m *Replacement) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *Replacement) GetRange() *FixRange {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Replacement) GetNewContent() string {
	if m != nil && m.NewContent != nil {
		return *m.NewContent
	}
	return ""
}

// Defines a range of lines or bytes in a text.
// Indexing starts at position 0, the start position is inclusive and the
// end position is exclusive.
type FixRange struct {
	// If the start position specifies the byte field, then the end position
	// also should.
	// Similarly, if the start position specifies the line field, then the end
	// position also should.
	// The start position (in either specification) must be less than or equal
	// to the end position.
	// Indexing starts at position 0, the start position is inclusive and the
	// end position is exclusive.
	Start            *FixRange_Position `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End              *FixRange_Position `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *FixRange) Reset()         { *m = FixRange{} }
func (m *FixRange) String() string { return proto.CompactTextString(m) }
func (*FixRange) ProtoMessage()    {}

func (m *FixRange) GetStart() *FixRange_Position {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *FixRange) GetEnd() *FixRange_Position {
	if m != nil {
		return m.End
	}
	return nil
}

type FixRange_Position struct {
	// Positions can either be line-based or byte-based.
	// Offset is from the start of the file.
	Line             *uint32 `protobuf:"varint,1,opt,name=line" json:"line,omitempty"`
	Byte             *uint32 `protobuf:"varint,2,opt,name=byte" json:"byte,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FixRange_Position) Reset()         { *m = FixRange_Position{} }
func (m *FixRange_Position) String() string { return proto.CompactTextString(m) }
func (*FixRange_Position) ProtoMessage()    {}

func (m *FixRange_Position) GetLine() uint32 {
	if m != nil && m.Line != nil {
		return *m.Line
	}
	return 0
}

func (m *FixRange_Position) GetByte() uint32 {
	if m != nil && m.Byte != nil {
		return *m.Byte
	}
	return 0
}

// A collection of fields containing additional category or environment-specific
// data.
type AdditionalData struct {
	// The time this note was generated. Used to disambiguate when analysis tools
	// produce notes nondeterministically.
	GenerationTimestampMillis *uint64 `protobuf:"varint,1,opt,name=generation_timestamp_millis" json:"generation_timestamp_millis,omitempty"`
	XXX_unrecognized          []byte  `json:"-"`
}

func (m *AdditionalData) Reset()         { *m = AdditionalData{} }
func (m *AdditionalData) String() string { return proto.CompactTextString(m) }
func (*AdditionalData) ProtoMessage()    {}

func (m *AdditionalData) GetGenerationTimestampMillis() uint64 {
	if m != nil && m.GenerationTimestampMillis != nil {
		return *m.GenerationTimestampMillis
	}
	return 0
}

func init() {
	proto.RegisterEnum("shipshape_proto.Note_Severity", Note_Severity_name, Note_Severity_value)
}
