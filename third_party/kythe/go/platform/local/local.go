// Package local simulates a compilation index for a single compilation based
// on a collection of files provided locally, either read from the local system
// or generated by a test case.  This permits analysis of local data for repro
// or testing purposes to re-use the same code pathways as other analyses.
//
// Example:
//   // Create an empty local compilation.
//   comp := local.NewCompilation()
//
//   // Add directories relative to which input files may be found.  Each
//   // directory will be tried in order when a file is added that does not
//   // resolve by its own path.
//   comp.AddDirectory("/some/local/directory/path")
//   comp.AddDirectory("/another/directory/path")
//
//   // Add required inputs from local files.
//   for _, path := range inputPaths {
//     if err := comp.AddFile(path); err != nil {
//       log.Error(err)
//     }
//   }
//
//   // Add required inputs from other data sources.
//   comp.AddData("foobar", []byte("some random content"))
//
//   // Mark an input as a source file.
//   comp.SetSource("foobar")
//
//   // Set analysis target, output path, build status.
//   comp.SetOutput("file/go/indexinfo.a")
//   comp.SetHasErrors(false)
//
//   // Make any other desired modifications to the underlying proto.
//   cu.Proto.GoArguments = &apb.GoArguments{...}
//
package local

import (
	"crypto/sha256"
	"encoding/hex"
	"io/ioutil"
	"path/filepath"

	"third_party/kythe/go/storage/files"

	apb "third_party/kythe/proto/analysis_proto"
	spb "third_party/kythe/proto/storage_proto"

	"code.google.com/p/goprotobuf/proto"
)

// A Compilation provides an interface to build a CompilationUnit message for a
// collection of files held in memory, and implements the analysis.Fetcher
// interface to provide access to those files.
type Compilation struct {
	Proto *apb.CompilationUnit // The compilation message being constructed.

	data  map[string][]byte
	paths []string
}

// NewCompilation returns a new empty Compilation.
func NewCompilation() *Compilation {
	return &Compilation{
		Proto: new(apb.CompilationUnit),
		data:  make(map[string][]byte),
	}
}

// Fetch returns the contents of the specified file from the index, or
// analysis.ErrNotFound if the file is not known.
// Implements the analysis.Fetcher interface.
//
// This implementation requires a path, and ignores the digest if given.
func (c *Compilation) Fetch(path, digest string) ([]byte, error) {
	if data, ok := c.data[path]; ok {
		return data, nil
	}
	return nil, files.ErrNotFound
}

// FileData is a wrapper for the Fetch method.
// Implements the files.FileStore interface.
// This implementation requires a path, and ignores the digest if given.
func (c *Compilation) FileData(path, digest string) ([]byte, error) {
	return c.Fetch(path, digest)
}

// AddData adds the specified data to the required inputs for the index, using
// name as the nominal input path.  If an input already exists with that name,
// it is replaced with the new data.
func (c *Compilation) AddData(name string, data []byte) {
	input := &apb.CompilationUnit_FileInput{
		Info: &apb.FileInfo{
			Path:   &name,
			Digest: proto.String(hexDigest(data)),
		},
	}
	if old := c.findInput(name); old == nil {
		c.Proto.RequiredInput = append(c.Proto.RequiredInput, input)
	} else {
		*old = *input
	}
	c.data[name] = data
}

// SetSource marks the specified name as a "source" file for the compilation.
// This has no effect if the name is not already known as a required input.
func (c *Compilation) SetSource(name string) {
	if _, ok := c.data[name]; !ok {
		return
	}
	if !c.hasSource(name) {
		c.Proto.SourceFile = append(c.Proto.SourceFile, name)
	}
}

func (c *Compilation) hasSource(name string) bool {
	for _, src := range c.Proto.SourceFile {
		if src == name {
			return true
		}
	}
	return false
}

// AddFile reads the contents of the specified file and adds it to the index.
// It is a convenience wrapper that combines ioutil.ReadFile with AddData.
// If path is not found as written, AddFile looks for the same path under each
// added directory in order.
func (c *Compilation) AddFile(path string) error {
	data, err := ioutil.ReadFile(path)
	if err == nil {
		c.AddData(path, data)
		return nil
	}
	for _, dir := range c.paths {
		p := filepath.Join(dir, path)
		if data, err := ioutil.ReadFile(p); err == nil {
			c.AddData(path, data)
			return nil
		}
	}
	return err
}

func (c *Compilation) findInput(path string) *apb.CompilationUnit_FileInput {
	for _, input := range c.Proto.RequiredInput {
		if input.GetInfo().GetPath() == path {
			return input
		}
	}
	return nil
}

// AddDirectory adds a directory path in which paths to AddFile may be found.
func (c *Compilation) AddDirectory(path string) {
	c.paths = append(c.paths, path)
}

// SetOutput sets the output path for the compilation.
func (c *Compilation) SetOutput(path string) { c.Proto.OutputKey = &path }

// SetSignature sets the Signature field of the compilation's VName.
// If the VName of the compilation is nil, then it creates one.
func (c *Compilation) SetSignature(signature string) {
	if c.Proto.VName == nil {
		c.Proto.VName = &spb.VName{Signature: &signature}
	} else {
		c.Proto.VName.Signature = &signature
	}
}

// SetCorpus sets the Corpus field of the compilation's VName.
// If the VName of the compilation is nil, then it creates one.
func (c *Compilation) SetCorpus(corpus string) {
	if c.Proto.VName == nil {
		c.Proto.VName = &spb.VName{Corpus: &corpus}
	} else {
		c.Proto.VName.Corpus = &corpus
	}
}

// SetHasErrors sets whether the compilation has compilation errors.
// Note this does not actually cause errors to occur, it just sets the value in
// the compilation unit message seen by an analyzer.
func (c *Compilation) SetHasErrors(errs bool) { c.Proto.HasCompileErrors = &errs }

func hexDigest(data []byte) string {
	h := sha256.New()
	h.Write(data)
	return hex.EncodeToString(h.Sum(nil))
}
